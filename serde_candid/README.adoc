= Candid Serialization library in Rust

== Using the library
* Example
[source,rust]
extern crate serde_candid;
use serde_candid::{Encode, Decode};
// Serialization
let bytes = Encode!(&[(42, "text")], &(42, "text"));
// Deserialization
Decode!(&bytes, a: Vec<(i64, &str)>, b: (i32, String));
assert_eq!(a, [(42, "text")]);
assert_eq!(b, (42i32, "text".to_string()));

* Serialize/Deserialize struct/enum
[source,rust]
#[derive(CandidType, Deserialize)]
struct List {
    head: i32,
    tail: Option<Box<List>>,
}
let list = List { head: 42, tail: None };
let bytes = Encode!(&list);
Decode!(&bytes, l: List);

* Inspect Candid type
[source,rust]
#[derive(CandidType)]
struct List { head: i32, tail: Option<Box<List>> }
assert_eq!(List::ty(),
           Type::Record(vec![
               field("head", Type::Int),
               field("tail", Type::Opt(Box::new(
                   Type::Knot(TypeId::of::<List>()))))])               
);


== Remaining items
* Limit recursion depth and heap size for deserialization
* Support future values
* Optimize for `new struct` type
* Refactor serialization to use serde
* Import `.did` file in Rust


